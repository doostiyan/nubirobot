import base64
import json
from json.decoder import JSONDecodeError
from typing import List, Dict

import bip32utils
import requests
from cryptography.fernet import Fernet
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from django.conf import settings

from exchange.base.logging import report_event, report_exception
from exchange.base.models import get_currency_codename, Currencies
from exchange.base.parsers import parse_choices
from exchange.blockchain.tasks import task_generate_addresses


def symmetric_decrypt(cypher: bytes, password: bytes):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b'2023786',  # salt is fixed due to possibility of the future decryptions.
        iterations=100000,
        backend=default_backend()
    )
    key = base64.urlsafe_b64encode(kdf.derive(password))
    fnet = Fernet(key)
    print(cypher)
    return fnet.decrypt(cypher)

class GeneralBlockchainWallet:
    currency = None
    coin_type = 195
    use_mainnet = False

    def pub_key_to_address(self, pub_key):
        raise Exception('Must be overridden by child')

    def get_child_key(self, xpub, purpose=44):
        # m / 'purpose' / coin_type' / account' / change / address_
        return bip32utils.BIP32Key.fromExtendedKey(xpub)

    def parse_xpub(self, xpub, number, base_index, purpose=44):
        child_key = self.get_child_key(xpub, purpose)
        addresses = []
        base_index = int(base_index)
        for index in range(base_index, base_index + int(number)):
            index_key = child_key.ChildKey(index)
            pub_key = index_key.PublicKey()
            address = self.pub_key_to_address(pub_key)
            addresses.append({'address': address, 'index': index})
        return addresses

    def create_wallets(self, xpub, number, wallet_name, base_index):
        from exchange.wallet.models import AvailableDepositAddress

        addresses = self.parse_xpub(xpub, number, base_index)
        for address_info in addresses:
            try:
                AvailableDepositAddress.objects.get(currency=self.currency, address=address_info['address'])
            except AvailableDepositAddress.DoesNotExist:
                AvailableDepositAddress.objects.create(
                    currency=self.currency,
                    address=address_info['address'],
                    description="{}: {}".format(wallet_name, address_info['index'])
                )

    @classmethod
    def validate_cold_addresses(cls, address: str, currency: int, address_type: str) -> bool:
        """ Validates address based on the provided address type and currency.

        This method checks if the given address(normally generated by cold-ui) is valid for the specified currency
        and address type. It uses a dictionary of validation rules to determine the appropriate validation function.

        Args:
            address (str): The cryptocurrency address to validate.
            currency (int): The currency code of the address.
            address_type (str): The type of address (e.g., 'miner', 'segwit', 'eoa_v1', etc.).

        Returns:
            bool: True if the address is valid, False otherwise.

        Note:
            This method uses internal validation functions from exchange.blockchain.validators.
            The actual validation logic depends on the currency and address type.
        """
        from exchange.blockchain.validators import validate_crypto_address, validate_bech32_address

        def validate_segwit_address():
            mainnet_segwit_btc_hrp = 'bc'
            return (
                currency == Currencies.btc
                and validate_bech32_address(mainnet_segwit_btc_hrp, address, currency)
            )
        def validate_contract1():
            return (
                currency == Currencies.trx
                and validate_crypto_address(address, currency)
            )
        def validate_contract2():
            eth_like_currencies = [Currencies.eth, Currencies.bsc, Currencies.ftm, Currencies.pol, Currencies.arb,
                                   Currencies.one, Currencies.avax, Currencies.ETC]
            return (
                currency in eth_like_currencies
                and validate_crypto_address(address, currency)
            )
        def validate_eoa_v1():
            eth_compatible_currencies = [Currencies.eth, Currencies.bsc, Currencies.ftm, Currencies.pol, Currencies.arb,
                                   Currencies.one, Currencies.avax, Currencies.ETC, Currencies.trx]
            return (
                currency in eth_compatible_currencies
                and validate_crypto_address(address, currency)
            )
        def validate_address():
            return (
                validate_crypto_address(address, currency)
            )
        def invalid_address_type():
            return False

        rules = {
            'miner': validate_segwit_address,
            'segwit': validate_segwit_address,
            'eoa_v1': validate_address,
            'contract': validate_address,
            'contract2': validate_address,
            'standard': validate_address
        }
        return rules.get(address_type, invalid_address_type)()


    @classmethod
    def create_wallet_from_cold(cls, token, currency, wallet_name):
        from exchange.wallet.models import ADDRESS_TYPE

        url = settings.COLD_WALLET_URL
        data = {
            'token': token,
            'api_key': settings.COLD_API_KEY
        }
        response = requests.post(url + '/s7bSHUBr/wallet_creation_status/', json=data, timeout=30)
        response.raise_for_status()
        wallet_info = response.json()
        if wallet_info.get('status') != 'Success':
            return wallet_info.get('message')

        file_name = wallet_info.get('file_name')
        data = {
            'file_name': file_name,
            'api_key': settings.COLD_API_KEY
        }
        response = requests.post(url + '/s7bSHUBr/get_addresses_file/', json=data, timeout=30)
        response.raise_for_status()
        addresses_raw = response.content
        addresses_raw = addresses_raw.splitlines()
        if not (addresses_raw[0] == b'====== Nobitex Adresses Start ====='
                and addresses_raw[-1] == b'===== END OF Nobitex Addresses ===='):
            msg = '[ERROR] The addresses file is corrupted.'
            report_event(msg)
            return msg
        addresses_list_raw = symmetric_decrypt(addresses_raw[1], settings.COLD_SYMMETRIC_KEY.encode())
        try:
            addresses_info = json.loads(addresses_list_raw)
        except JSONDecodeError:
            report_exception()
            return '[ERROR] The addresses is not json format.'
        addresses_type = None
        addresses_type_code = None
        if isinstance(addresses_info, List):
            # Deprecated addresses format
            addresses_list = addresses_info
        elif isinstance(addresses_info, Dict):
            # New addresses format
            addresses_list = addresses_info.get('addresses') or {}
            addresses_meta = addresses_info.get('meta') or {}
            if addresses_meta.get('currency_code', '').lower() != get_currency_codename(currency):
                return '[ERROR] The currency does not match with file info.'
            addresses_type_code = addresses_meta.get('type', 'standard').lower()
            addresses_type = parse_choices(ADDRESS_TYPE, addresses_type_code)
        else:
            return '[ERROR] The information contains invalid format.'
        address_validation_status = True
        if any(isinstance(address, dict) for address in addresses_list):
            addresses_info_list = []
            for address_info in addresses_list:
                address = address_info['address']
                if not cls.validate_cold_addresses(address, currency, addresses_type_code):
                    address_validation_status = False
                description = f'{wallet_name}'
                salt = address_info.get('salt')
                addresses_info_list.append({
                    'address': address,
                    'description': description,
                    'address_type': addresses_type,
                    'salt': salt
                })
        else:
            addresses_info_list = []
            for address in addresses_list:
                if not cls.validate_cold_addresses(address, currency, addresses_type_code):
                    address_validation_status = False
                addresses_info_list.append({
                    'address': address,
                    'description': f'{wallet_name}',
                    'address_type': addresses_type,
                    'salt': None
                })
        if address_validation_status:
            task_generate_addresses.delay(addresses_info_list=addresses_info_list, currency=currency)
        else:
            report_event(f'[CREATE WALLET FROM COLD] Failed Address validation on wallet: {wallet_name}')
            return '[FAILED] Address validation failed.'
        return '[SUCCESS] Addresses will be created. Please ensure the creation after few minutes.'
