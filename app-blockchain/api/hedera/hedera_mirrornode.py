import base64
from decimal import Decimal
from typing import List

from django.conf import settings

from exchange.blockchain.api.general.general import GeneralApi, ResponseValidator, ResponseParser
from exchange.blockchain.utils import BlockchainUtilsMixin

if settings.BLOCKCHAIN_CACHE_PREFIX == 'cold_':
    from wallet.models import CURRENCIES as Currencies
else:
    from exchange.base.parsers import parse_utc_timestamp
    from exchange.base.models import Currencies

from exchange.blockchain.api.general.dtos.dtos import TransferTx


class MirrorNodeHederaValidator(ResponseValidator):
    min_valid_tx_amount = Decimal(0)
    precision = 8

    @classmethod
    def validate_balance_response(cls, balance_response) -> bool:
        if not balance_response:
            return False
        if not balance_response.get('balances'):
            return False
        if not balance_response.get('balances')[0]:
            return False
        if not balance_response.get('balances')[0].get('balance'):
            return False
        return True

    @classmethod
    def validate_tx_details_response(cls, tx_details_response) -> bool:
        if not tx_details_response:
            return False
        if not tx_details_response.get('transactions'):
            return False
        transaction = tx_details_response.get('transactions')[0]
        return cls.validate_transaction(transaction)

    @classmethod
    def validate_transaction(cls, transaction) -> bool:
        if not transaction.get('name') or transaction.get('name').casefold() != 'CRYPTOTRANSFER'.casefold():
            return False
        if not transaction.get('transaction_id'):
            return False
        if not transaction.get('transaction_hash'):
            return False
        if transaction.get('result').casefold() != 'SUCCESS'.casefold():
            return False
        if transaction.get('token_transfers'):
            return False
        # Hedera supports multi-send so if the field of transfers is empty the transaction is not valid
        if not transaction.get('transfers'):
            return False
        # A zero nonce represents user submitted transactions while a non-zero nonce is generated by main nodes.
        if transaction.get('nonce') != 0:
            return False
        return True

    @classmethod
    def validate_address_txs_response(cls, address_txs_response) -> bool:
        if not address_txs_response:
            return False
        if not address_txs_response.get('transactions'):
            return False
        return True

    @classmethod
    def validate_transfer(cls, transfer, address=None) -> bool:
        if not transfer.get('account'):
            return False
        if transfer.get('is_approval'):
            return False
        if transfer.get('amount') is None or BlockchainUtilsMixin.from_unit(abs(transfer.get('amount')),
                                                                            cls.precision) <= cls.min_valid_tx_amount:
            return False
        return True

    @staticmethod
    def validate_count_of_transfers_to_same_account(address, transaction):
        count = 0
        for transfer in transaction.get('transfers'):
            if transfer.get('account') == address:
                # to filter txs with more than one transfer with same account
                count += 1
        if count != 1:
            return False
        return True


class MirrorNodeHederaResponseParser(ResponseParser):
    validator = MirrorNodeHederaValidator
    symbol = 'HBAR'
    currency = Currencies.hbar
    precision = 8

    @classmethod
    def parse_balance_response(cls, balance_response) -> Decimal:
        if cls.validator.validate_balance_response(balance_response):
            return BlockchainUtilsMixin.from_unit(balance_response.get('balances')[0].get('balance'),
                                                  precision=cls.precision)
        return Decimal(0)

    @classmethod
    def parse_tx_details_response(cls, tx_details_response, block_head) -> List[TransferTx]:
        if cls.validator.validate_tx_details_response(tx_details_response):
            transaction = tx_details_response.get('transactions')[0]
            tx_hash = transaction.get('transaction_id')
            tx_fee = BlockchainUtilsMixin.from_unit(transaction.get('charged_tx_fee'), cls.precision)
            valid_transfers = list()
            transfers: List[TransferTx] = []
            withdraw_amount = 0
            # Hedera supports multi transfer so we create the TransferTx object based on transfers in transactions
            # We try to find the from address based on the negative amount in transfers.
            # Then we for on valid transfers and ignore the negative amount to create transfer objects
            # containing both from_address and to_address
            # The point is that for each n valid transfers in a transaction, we should create n-1 TransferTx object
            # Be aware that if a transaction contains an invalid transfer, the whole transaction is invalid
            # Another point is that we may have some staking rewards and we should know that rewards can not be
            # more than actual amounts so we find the from_address via this point
            for transfer in transaction.get('transfers'):
                if cls.validator.validate_transfer(transfer):
                    if transfer.get('amount') < 0 and abs(transfer.get('amount')) > withdraw_amount:
                        from_address = transfer.get('account')
                        withdraw_amount = abs(transfer.get('amount'))
                    elif transfer.get('amount') > 0 and transfer.get('amount') > transaction.get(
                            'charged_tx_fee'):
                        valid_transfers.append(transfer)
                else:
                    break
            else:
                date, ns = transaction.get('consensus_timestamp').split('.')
                for valid_transfer in valid_transfers:
                    to_address = valid_transfer.get('account')
                    # In here we check if an address is in accounts of staking-reward-list
                    # then we should decrease the amount of reward from the transfer
                    # because the amount of transaction should not include that
                    if transaction.get('staking_reward_transfers'):
                        for reward_transfer in transaction.get('staking_reward_transfers'):
                            if to_address == reward_transfer.get('account'):
                                valid_transfer['amount'] -= reward_transfer.get('amount')
                    transfer = TransferTx(
                        tx_hash=tx_hash,
                        tx_fee=tx_fee,
                        memo=base64.b64decode(transaction.get('memo_base64')).decode('utf-8'),
                        from_address=from_address,
                        to_address=to_address,
                        success=True,
                        value=BlockchainUtilsMixin.from_unit(valid_transfer.get('amount'), cls.precision),
                        date=parse_utc_timestamp(date),
                        block_hash=None,
                        confirmations=1,
                        symbol=cls.symbol,
                        token=None,
                        block_height=None
                    )
                    transfers.append(transfer)
            if transfers:
                return transfers

    @classmethod
    def parse_address_txs_response(cls, address, address_txs_response, block_head) -> List[TransferTx]:
        address_txs: List[TransferTx] = []
        if cls.validator.validate_address_txs_response(address_txs_response):
            transactions = address_txs_response.get('transactions')
            address_txs: List[TransferTx] = []
            for transaction in transactions:
                if cls.validator.validate_transaction(transaction):
                    if cls.validator.validate_count_of_transfers_to_same_account(address, transaction):
                        tx_hash = transaction.get('transaction_id')
                        tx_fee = BlockchainUtilsMixin.from_unit(transaction.get('charged_tx_fee'), cls.precision)
                        valid_transfers = list()
                        withdraw_amount = 0
                        for transfer in transaction.get('transfers'):
                            if cls.validator.validate_transfer(transfer, address):
                                if transfer.get('amount') < 0 and abs(transfer.get('amount')) > withdraw_amount:
                                    from_address = transfer.get('account')
                                    withdraw_amount = abs(transfer.get('amount'))
                                elif transfer.get('amount') > 0 and transfer.get('amount') > transaction.get(
                                        'charged_tx_fee'):
                                    valid_transfers.append(transfer)
                            else:
                                break
                        else:
                            date, ns = transaction.get('consensus_timestamp').split('.')
                            memo = base64.b64decode(transaction.get('memo_base64')).decode('utf-8')
                            for transfer in valid_transfers:
                                to_address = transfer.get('account')
                                if transaction.get('staking_reward_transfers'):
                                    for reward_transfer in transaction.get('staking_reward_transfers'):
                                        if to_address == reward_transfer.get('account'):
                                            transfer['amount'] -= reward_transfer.get('amount')
                                try:
                                    value = BlockchainUtilsMixin.from_unit(transfer.get('amount'), cls.precision)
                                except:
                                    continue
                                address_tx = TransferTx(
                                    tx_hash=tx_hash,
                                    tx_fee=tx_fee,
                                    memo=memo,
                                    from_address=from_address,
                                    to_address=to_address,
                                    success=True,
                                    value=value,
                                    date=parse_utc_timestamp(date),
                                    block_hash=None,
                                    confirmations=1,
                                    symbol=cls.symbol,
                                    token=None,
                                    block_height=None

                                )
                                address_txs.append(address_tx)

        return address_txs


class MirrorNodeHederaApi(GeneralApi):
    parser = MirrorNodeHederaResponseParser
    _base_url = 'https://mainnet-public.mirrornode.hedera.com/'
    testnet_url = 'https://testnet.mirrornode.hedera.com/'
    cache_key = 'hbar'
    USE_PROXY = True if not settings.IS_VIP else False
    instance = None
    rate_limit = 0.01
    need_block_head_for_confirmation = False
    supported_requests = {
        'get_balance': 'api/v1/balances?account.id={address}',
        'get_address_txs': 'api/v1/transactions?account.id={address}&limit='
                           '25&transactiontype=cryptotransfer&result=success',
        'get_tx_details': 'api/v1/transactions/{tx_hash}'
    }

    @classmethod
    def get_headers(cls):
        return None

class QuickNodeHederaApi(MirrorNodeHederaApi):
    _base_url = 'https://sly-bitter-violet.hedera-mainnet.quiknode.pro/c3faa5dbd491bcd560cd8d0eeff85b48fd3895db/'
    instance = None


    @classmethod
    def get_headers(cls):
        return {
            'Content-Type': 'application/json'
        }
